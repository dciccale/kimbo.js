<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - event.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>event.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">591</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.63</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">Kimbo.define(&#039;events&#039;, function (_) {

  &#039;use strict&#039;;

  var query = Kimbo.require(&#039;query&#039;);
  var _guid = 1;
  var MOUSE_EVENT_RE = /^(?:mouse|menu)|click/;
  var KEY_EVENT_RE = /^key/;
  var DEFAULT_EVENT_PROPS = [
    &#039;altKey&#039;, &#039;bubbles&#039;, &#039;cancelable&#039;, &#039;ctrlKey&#039;, &#039;currentTarget&#039;, &#039;defaultPrevented&#039;, &#039;eventPhase&#039;,
    &#039;metaKey&#039;, &#039;relatedTarget&#039;, &#039;shiftKey&#039;, &#039;target&#039;, &#039;timeStamp&#039;, &#039;type&#039;, &#039;view&#039;, &#039;which&#039;
  ];
  var MOUSE_EVENT_PROPS = [
    &#039;button&#039;, &#039;buttons&#039;, &#039;clientX&#039;, &#039;clientY&#039;, &#039;fromElement&#039;,
    &#039;offsetX&#039;, &#039;offsetY&#039;, &#039;screenX&#039;, &#039;screenY&#039;, &#039;toElement&#039;
  ];
  var KEY_EVENT_PROPS = [&#039;char&#039;, &#039;charCode&#039;, &#039;key&#039;, &#039;keyCode&#039;];

  // Gestures fallback for not mobile environment
  var GESTURES_FALLBACK = Kimbo.isMobile() ? {} : {
    touchstart: &#039;mousedown&#039;,
    touchmove: &#039;mousemove&#039;,
    touchend: &#039;mouseup&#039;,
    touch: &#039;click&#039;,
    doubletap: &#039;dblclick&#039;,
    orientationchange: &#039;resize&#039;
  };
  var handlersHash = {};
  var fixEventProps = {};
  var specialEvents = {};

  function _fixEvent(event) {
    var originalEvent, eventProps, props;

    // Already fixed
    if (event[Kimbo.ref]) {
      return event;
    }

    // Get event properties
    originalEvent = event;
    eventProps = fixEventProps[event.type] || [];
    props = DEFAULT_EVENT_PROPS.concat(eventProps);

    // Create a new event writable custom event object
    event = new Kimbo.Event(originalEvent);

    // Set event props to Kimbo.Event object
    Kimbo.forEach(props, function (prop) {
      event[prop] = originalEvent[prop];
    });

    return event;
  }

  // Return element id
  function _getElementId(element) {
    return element._guid || (element._guid = _guid++);
  }

  // Get element handlers for the specified type
  function _getHandlers(elementId, type) {
    var events = ((handlersHash[elementId] || {}).events || {});

    return (type ? events[type] : events) || [];
  }

  // Register events to dom elements
  function _addEvent(element, type, callback, data, selector) {

    // TODO: element should use Kimbo.ref and the handler the _guid
    var elementId = _getElementId(element);
    var elementHandlers = handlersHash[elementId];
    var origType = type;
    var events, handlers, handleObj, handler;

    // Could be a special type like mouseenter/mouseleave
    type = specialEvents[type] ? specialEvents[type].origType : type;

    // Create hash for this element if first init
    if (!elementHandlers) {
      handlersHash[elementId] = elementHandlers = {};
    }

    // Create events object if first init
    events = elementHandlers.events;
    if (!events) {
      elementHandlers.events = events = {};
    }

    // Create the handler for this element if first init
    handler = elementHandlers.handler;
    if (!handler) {
      elementHandlers.handler = handler = function () {
        return _dispatchEvent.apply(element, arguments);
      };
    }

    // Create handler object
    handleObj = {
      type: type,
      origType: origType,
      data: data,
      callback: callback,
      selector: selector
    };

    // Only add an event listener one time for each type of event
    handlers = events[type];
    if (!handlers) {

      // Array of handlers for the current type
      handlers = events[type] = [];
      handlers.delegateCount = 0;

      // Add event
      if (element.addEventListener) {
        element.addEventListener(type, handler, false);
      }
    }

    // Add to handlers hash, delegates first
    if (selector) {
      handlers.splice(handlers.delegateCount++, 0, handleObj);

    } else {
      handlers.push(handleObj);
    }
  }

  // Unregister events from dom elements
  function _removeEvent(element, type, callback, selector) {
    var elementId = _getElementId(element);
    var handleObj, handlers, name, i;

    handlers = _getHandlers(elementId, type);

    // Return if no handlers for the current event type
    if (type &amp;&amp; !handlers.length) {
      return;
    }

    // Remove all handlers if no type provided
    if (!type) {
      for (name in handlers) {
        if (handlers.hasOwnProperty(name)) {
          _removeEvent(element, name, callback, selector);
        }
      }
    }

    // Remove handlers that match
    for (i = 0; i &lt; handlers.length; i++) {
      handleObj = handlers[i];
      if ((!callback || callback === handleObj.callback) &amp;&amp; (!selector || selector === handleObj.selector)) {

        // Remove current handler from stack
        handlers.splice(i--, 1);

        // Decrement delegate count
        if (handleObj.selector) {
          handlers.delegateCount--;
        }
      }
    }

    // If no more events for the current type remove the listener and delete its hash
    if (!handlers.length) {
      element.removeEventListener(type, handlersHash[elementId].handler, false);
      delete handlersHash[elementId].events[type];
    }

    // Remove kimbo reference if element have no more events
    // If (Kimbo.isEmptyObject(handlersHash[elementId].events)) {
    //   delete handlersHash[elementId];
    //   delete element._guid;
    // }
  }

  // Triggers a provided event type
  function _triggerEvent(element, type, data) {

    /* jshint validthis: true */
    var currentElement, lastElement, eventTree, elementId, event;

    // Don&#039;t do events if element is text or comment node
    // Or if there is no event type at all or type is not a string
    if ((element &amp;&amp; (element.nodeType === 3 || element.nodeType === 8)) ||
      !type || !Kimbo.isString(type)) {
        return this;
    }

    // Try triggering native focus and blur events
    if (type === &#039;focus&#039; || type === &#039;blur&#039;) {
      try {
        return element[type]();
      } catch (e) {}
    }

    // Create a new writable custom event object
    event = new Kimbo.Event(type);

    // Triggered programatically
    event.isTrigger = true;

    // Set the target
    if (!event.target) {
      event.target = element;
    }

    // Include data if any
    data = data ? Kimbo.makeArray(data) : [];

    // Event goes first
    data.unshift(event);

    // Generate a stack of [element, event] to be triggered
    eventTree = [[element, type]];
    if (!Kimbo.isWindow(element)) {

      // Get all parent elements to bubble event later
      for (currentElement = element.parentNode; currentElement; currentElement = currentElement.parentNode) {
        eventTree.push([currentElement, type]);
        lastElement = currentElement;
      }

      // Only add window object if we got to document (e.g., not plain obj or detached DOM)
      if (lastElement &amp;&amp; lastElement === element.ownerDocument) {
        eventTree.push([window, type]);
      }
    }

    // Fire handlers up to the document (or the last element)
    Kimbo.forEach(eventTree, function (branch) {

      // Element
      currentElement = branch[0];

      // Type
      event.type = branch[1];

      // Get element id
      elementId = currentElement._guid;

      // If the current element has events of the specified type, dispatch them
      if (elementId &amp;&amp; _getHandlers(elementId, type)) {
        handlersHash[elementId].handler.apply(currentElement, data);
      }
    });
  }

  // Own defined dispatchEvent()
  function _dispatchEvent(event) {
    /* jshint -W040 */

    // Use own event object
    event = _fixEvent(event);

    var elementId = _getElementId(this);
    var handlers = _getHandlers(elementId, event.type);
    var delegateCount = handlers.delegateCount;
    var args = _.slice.call(arguments);
    var handlerQueue = [];
    var currentElement, ret, selMatch, matches, handleObj, selector, i;

    // Set the native event to be the fixed event
    args[0] = event;

    // Save the delegate target element
    event.delegateTarget = this;

    // Get delegated handlers if any
    if (delegateCount) {

      // Go up to the dom finding the elements that matches the current selector from delegated event
      for (currentElement = event.target; currentElement !== this; currentElement = currentElement.parentNode || this) {

        // Don&#039;t do events on disabled elements
        if (currentElement.disabled !== true || event.type !== &#039;click&#039;) {
          selMatch = {};
          matches = [];

          // Loop throgh delegated events
          for (i = 0; i &lt; delegateCount; i++) {

            // Get its handler
            handleObj = handlers[i];

            // Get its selector
            selector = handleObj.selector;

            if (!selMatch[selector]) {
              selMatch[selector] = _.kimbo(currentElement).is(selector);
            }

            if (selMatch[selector]) {
              matches.push(handleObj);
            }
          }

          if (matches.length) {
            handlerQueue.push({elem: currentElement, matches: matches});
          }
        }
      }
    }

    // Add the remaining not delegated handlers
    if (handlers.length &gt; delegateCount) {
      handlerQueue.push({elem: this, matches: handlers.slice(delegateCount)});
    }

    // Fire callbacks queue
    Kimbo.forEach(handlerQueue, function (handler) {

      // Only fire handler if event wasnt stopped
      if (!event.isPropagationStopped()) {
        event.currentTarget = handler.elem;

        Kimbo.forEach(handler.matches, function (handleObj) {

          // Only fire bubble if not stopped
          if (!event.isImmediatePropagationStopped()) {
            event.data = handleObj.data;
            event.handleObj = handleObj;

            // Call original callback, check if its an special event first
            ret = ((specialEvents[handleObj.origType] || {}).handle || handleObj.callback).apply(handler.elem, args);

            // If callback returns false, stop the event
            if (ret === false) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        });
      }
    });

    /* jshint +W040 */
  }

  function _returnFalse() {
    return false;
  }

  function _returnTrue() {
    return true;
  }

  Kimbo.Event = function (event) {

    // Is event object
    if (event &amp;&amp; event.type) {
      this.originalEvent = event;
      this.type = event.type;

      // The event may have been prevented
      // Check dom level 3 new attribute and set proper value
      if (event.defaultPrevented) {
        this.isDefaultPrevented = _returnTrue;
      } else {
        this.isDefaultPrevented = _returnFalse;
      }

    // Is event type
    } else {
      this.type = event;
    }

    // Create a timestamp if doesn&#039;t have one
    this.timeStamp = (event &amp;&amp; event.timeStamp) || Date.now();

    // Made by kimbo, yeah
    this[Kimbo.ref] = true;
  };

  // Dom-Level-3-Events compliant
  Kimbo.Event.prototype = {
    isDefaultPrevented: _returnFalse,
    isPropagationStopped: _returnFalse,
    isImmediatePropagationStopped: _returnFalse,

    preventDefault: function () {
      this.isDefaultPrevented = _returnTrue;

      // Original event is not present when trigger is called
      if (!this.isTrigger) {
        this.originalEvent.preventDefault();
      }
    },

    stopPropagation: function () {
      this.isPropagationStopped = _returnTrue;

      if (!this.isTrigger) {
        this.originalEvent.stopPropagation();
      }
    },

    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = _returnTrue;

      if (!this.isTrigger) {
        this.originalEvent.stopImmediatePropagation();
      }
    }
  };

  Kimbo.fn.extend({
    /*\
     * $(…).on
     [ method ]
     * Add an event handler to the selected elements.
     &gt; Parameters
     - type (string) A string name for the event to register.
     - selector (string) #optional Delegate an event providing a string selector.
     - data (any) #optional Data to be passed to the handler in `event.data` when an event is triggered.
     - callback (function) A callback function to execute when the event is triggered.
     &gt; Usage
     * Suppose a button element:
     | &lt;button id=&#039;btn&#039;&gt;click me&lt;/button&gt;
     * Register a click event handler
     | $(&#039;#btn&#039;).on(&#039;click&#039;, function (event) {
     |   console.log(&#039;clicked!&#039;, event);
     | });
     * There are shorthands for all events for example:
     | $(&#039;#btn&#039;).click(function (event) {
     |   console.log(&#039;clicked!&#039;, event);
     | });
     * Passing some data when registering the handler:
     | $(&#039;#btn&#039;).on(&#039;click&#039;, { name: &#039;denis&#039; }, function (event) {
     |   // Data passed is inside event.data
     |   console.log(&#039;name:&#039;, event.data.name);
     | });
     * Here is a list for all the shorthand methods available:
     | &#039;blur&#039;, &#039;change&#039;, &#039;click&#039;, &#039;contextmenu&#039;, &#039;dblclick&#039;, &#039;error&#039;,
     | &#039;focus&#039;, &#039;keydown&#039;, &#039;keypress&#039;, &#039;keyup&#039;, &#039;load&#039;, &#039;mousedown&#039;, &#039;mouseenter&#039;, &#039;mouseleave&#039;,
     | &#039;mousemove&#039;, &#039;mouseout&#039;, &#039;mouseup&#039;, &#039;mouseover&#039;, &#039;resize&#039;, &#039;scroll&#039;, &#039;select&#039;, &#039;submit&#039;, &#039;unload&#039;
    \*/
    on: function (type, selector, data, callback) {
      // Prepare the arguments

      // (type, callback)
      if (!data &amp;&amp; !callback) {
        callback = selector;
        data = selector = undefined;

      // (type, selector, callback)
      } else if (!callback) {
        if (Kimbo.isString(selector)) {
          callback = data;
          data = undefined;

        // (type, data, callback)
        } else {
          callback = data;
          data = selector;
          selector = undefined;
        }
      }

      // Don&#039;t add events if no callback
      if (!callback) {
        return this;
      }

      type = GESTURES_FALLBACK[type] || type;

      // Add the event
      return this.each(function (el) {
        _addEvent(el, type, callback, data, selector);
      });
    },

    /*\
     * $(…).off
     [ method ]
     * Remove an event handler to the selected elements for the specified type, or all of them if no type defined.
     &gt; Parameters
     - type (string) #optional A string name for the event to remove, or All if none specified.
     - selector (string) #optional A string selector to undelegate an event from that element.
     - callback (function) #optional A specific callback function if there are multiple registered under the same event type
     &gt; Usage
     * Suppose a button element:
     | &lt;button id=&#039;btn&#039;&gt;click me&lt;/button&gt;
     * Register a click event handler
     | $(&#039;#btn&#039;).on(&#039;click&#039;, function (event) {
     |   console.log(&#039;clicked!&#039;, event);
     | });
     * Remove the handler
     | $(&#039;#btn&#039;).off(&#039;click&#039;);
     * Also you could specify the handler for example:
     | var firstFunction = function () { console.log(&#039;first fn&#039;); };
     | var secondFunction = function () { console.log(&#039;second fn&#039;); };
     | var btn = $(&#039;#btn&#039;);
     | btn.click(firstFunction);
     | btn.click(secondFunction);
     * If you want to remove the click event only for the second function, do this:
     | btn.off(&#039;click&#039;, secondFunction);
     * Or if you want to remove All handlers (click and any other attached):
     | btn.off();
    \*/
    off: function (type, selector, callback) {

      // Prepare the arguments

      // (type, callback)
      if (Kimbo.isFunction(selector)) {
        callback = selector;
        selector = undefined;
      }

      // Remove the event
      return this.each(function (el) {
        _removeEvent(el, type, callback, selector);
      });
    },

    /*\
     * $(…).trigger
     [ method ]
     * Execute all handlers attached to the matched elements for the fiven event type.
     &gt; Parameters
     - type (string) #optional A string name for the event to remove, or All if none specified.
     - data (any) #optional Additional parameters to be passed to the handler in `event.data` when an event is triggered.
     &gt; Usage
     * Suppose a button element:
     | &lt;button id=&#039;btn&#039;&gt;click me&lt;/button&gt;
     * Register a click event handler
     | $(&#039;#btn&#039;).on(&#039;click&#039;, function (event, data) {
     |   console.log(&#039;name&#039;, data.name);
     | });
     * Trigger the event programatically passing some data:
     | $(&#039;#btn&#039;).trigger(&#039;click&#039;, { name: &#039;denis&#039; });
     | // &#039;name denis&#039;
     * Allow the handler to recieve multiple data:
     | $(&#039;#btn&#039;).on(&#039;click&#039;, function (event, name, last) {
     |   console.log(&#039;name&#039;, name);
     |   console.log(&#039;last&#039;, last);
     | });
     | $(&#039;#btn&#039;).trigger(&#039;click&#039;, [&#039;denis&#039;, &#039;ciccale&#039;]);
     | // Name denis
     | // Last ciccale
    \*/
    trigger: function (type, data) {
      return this.each(function (el) {
        _triggerEvent(el, type, data);
      });
    }
  });

  // Shortcut methods for each event type
  Kimbo.forEach([&#039;blur&#039;, &#039;change&#039;, &#039;click&#039;, &#039;contextmenu&#039;, &#039;dblclick&#039;, &#039;error&#039;,
    &#039;focus&#039;, &#039;keydown&#039;, &#039;keypress&#039;, &#039;keyup&#039;, &#039;load&#039;, &#039;mousedown&#039;, &#039;mouseenter&#039;, &#039;mouseleave&#039;, &#039;mousemove&#039;,
    &#039;mouseout&#039;, &#039;mouseup&#039;, &#039;mouseover&#039;, &#039;resize&#039;, &#039;scroll&#039;, &#039;select&#039;, &#039;submit&#039;, &#039;unload&#039;], function (type) {

    Kimbo.fn[type] = function (data, callback) {
      return arguments.length &gt; 0 ? this.on(type, null, data, callback) : this.trigger(type);
    };

    // Set event props for the specific type
    fixEventProps[type] = KEY_EVENT_RE.test(type) ? KEY_EVENT_PROPS : MOUSE_EVENT_RE.test(type) ? MOUSE_EVENT_PROPS : null;
  });

  // Fix mouseover and mouseout events to use mouseenter mouseleave
  Kimbo.forEach({
    mouseenter: &#039;mouseover&#039;,
    mouseleave: &#039;mouseout&#039;
  }, function (orig, fix) {
    specialEvents[orig] = {
      origType: fix,

      handle: function (event) {
        var target = this;
        var related = event.relatedTarget;
        var handleObj = event.handleObj;
        var ret;

        if (!related || (related !== target &amp;&amp; !query.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.callback.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
